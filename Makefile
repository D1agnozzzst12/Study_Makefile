
# main.exe: main.c main.h
# gcc.exe -o main.exe main.cpp
# Обратите внимание, что каждая команда обязана иметь отступы, индентация (стиль отступов) которых требует использовать для этого только символы табуляции (TAB).

# Правила выполнения команд
# Каждая команда выводится в терминале, чтобы этого избежать, можно добавить @ в начале или вызвать make с аргументом -s (silent), тогда каждая команда не будет выводиться.
# Команда с каждой новой строки выполняется в новом shell, чтобы этого избежать нужно перечислять команды одной строкой через ; (точку с запятой).
# Так же можно указать shell, SHELL=/bin/sh по умолчанию, можно изменить на SHELL=/bin/bash.
# Фиктивные цели
# С реальными целями все ясно, это просто файлы, которые должны быть созданы и, если их нет или они устарели, тогда мы вызываем нужные команды.

# Но зачем нужны фиктивные цели? Фиктивными целями может служить группа из реальных целей, например часто применяемая ALL, которая будет содержать в себе все цель по умолчанию.

# Можно выделить список часто применяемых:

# all - цель по умолчанию, если вызвать make без аргументов, если явно не указать, тогда будет вызвана первая в Makefile.
# clean - очищаем каталог от результата компиляции.
# install - установка, перенос скомпилированных файлов в необходимый системный каталог.
# uninstall - соотвественно, удаление из системы.
# Чтобы объявить такую цель, нужно использовать директиву .PHONY, на примере нашего списка объявим их следующим образом

# .PHONY: all clean install uninstall
# all: main.exe
# clean:
# rm -rf main.exe *.o
# main.o: main.c
# gcc -c -o main.o main.c
# main.exe: main.o
# gcc -o main.exe main.o
# install:
# install ./main.exe /ваш/путь
# uninstall:
# rm -rf /ваш/путь/main.exe
# Инкрементная компиляция
# Поскольку компиляция больших проектов может занимать долгие часы, а внося небольшую правку каждый раз тратить столько времени попросту не эффективно. Было принято решение разделить процесс компиляции на этапы.

# трансляция - процесс преобразования кода в объектный файл, который содержит бинарный код.
# линковка - объединение объектных файлов в результирующий исполняемый.
# Именно этим и занимается утилита make, отслеживает зависимости и вызывает команды, цели которых устарели или попросту отсутствуют.

# Переменные
# В скрипт-файле Makefile допустимо использование переменных, именовать их ЗАГЛАВНЫМИ буквами, является правилом хорошего тона.

# Переменные могут быть определены в разных местах

# default - переменная определена самим компилятором
# environment - переменная унаследована от окружения
# environment override - унаследована и переопределена через опцию -e
# file - определена в makefile
# override - переменная определена в makefile с директивой override
# automatic - автоматическая переменная
# все предопределенные правила, команды и переменные утилиты make можно посмотреть вызвав make -p

# Передача переменных в момент вызова make
# make CFLAGS=-O2 и CFLAGS=-O2 make — будет по-разному интерпретироваться. Т.е. в первом случае CFLAGS будет принудительно перезаписан, вне зависимости от того что прописано в самом makefile, а во втором — только если разрешил разработчик.

# Автоматические переменные
# например, для проверки заголовочных файлов, можно использовать следующую конструкцию

# main.o: main.cpp header_a.h header_b.h
# g++ -c -o main.o $
# отсюда $ будет содержать первый реквизит исполняемого правила, а именно main.cpp

# Перечень автоматических переменных

# $@ - имя файла цели.
# $% - имя элемента архива, если цель foo.a(bar.o), тогда $@ = foo.a, а $% = bar.o
# $ - имя первого пререквизита.
# $? - имена всех пререквизитов (разделены пробелами), которые новее, чем цель.
# $^ - имена всех пререквезитов (разделены пробелами), которые являются элементами архива.
# $+ - аналог $^, за исключением того, что не будут удалены дубли.
# $* - основа (stem), которая будет пол


hello:
	echo "hello man"
	echo "This line will print if the file hello does not exist."